h1. Sandbar

Sandbar is a library for web applications built on top of Compojure and Ring. It contains (or will contain) code to help with: 

* Scaling server side state
* Tables which may be filtered, sorted and paged
* Form layout, validation and error reporting
* Authorization and authentication
* User management
* CSS builder
* Some kind of interface to Lucene (Solr)

The project contains the library code as well as a reference application which uses it.

h2. Motivation

There is one major difference in philosophy between this project and Compojure or Ring. The main focus of this library is stateful web applications. There is not one right way to create a web application. Different applications have different requirements. Some benefit from a more stateful approach. But you will say, stateful does not scale? It does scale, it's just not as easy. The Compojure/Ring approach is more stateless and restful. Which is good for some applications. You can see this in the way sessions are implemented. They have chosen a functional style of session management. If your application is more stateful then it can sometimes be awkward to work with.

<img src="http://www.drawbacksolutions.com/images/fpl/ring-sessions.png" 
     alt="Ring Sessions" />

This library thinks of sessions that are more like your database except faster and without all of the database pain. You should be able to get something from and put something in the session from anywhere in your application. Working with the session should be orthogonal to the request response cycle.

<img src="http://www.drawbacksolutions.com/images/fpl/sandbar-sessions.png" 
     alt="Sandbar Sessions" />

In the past you have had a few choices as to where you would put session data. You can store it in memory, in a cookie or in your database. There is a problem with each of these. In memory does not scale. In a cookie you have limited space. In the database is too much work and too slow. Also, session data is transient. You usually only need it for a short period of time. It just seems wrong to mix this into your system of record.

The approach that I am advocating it to store session data in a memory-only, schema-free database. This library will have a simple interface to the session. For small applications the session will be stored in an atom in memory. When you need to start scaling you can switch to client-server mode without having to change any of your code. In client-server mode, the interface will handle sending and retrieving data from the session database. Because we are using an in-memory database it will be fast and because it is schema-free we will be able to store arbitrary maps without a lot of configuration.

h2. Running the reference application

The reference application demonstrates how to use the sandbar libraries.

To run the reference application, follow these steps:

# Create a MySQL database on localhost named idea_db
# Create a MySQL user named idea_user@localhost with password 123456789
# Give the above user all privileges on the idea_db database.
# "Install Leiningen":http://github.com/technomancy/leiningen
# Execute the following commands:

<pre>
<code> 
git clone git://github.com/brentonashworth/sandbar.git
cd sandbar
lein deps
lein test
lein repl
(load-file "src/testdrive.clj")
</code>
</pre>

You may now open a browser and go to http://localhost:8080/ideadb/.

There are two user accounts:

username: admin-user
password: admin

username: normal-user
password: password

Log in with one of these accounts and take it for a spin. The next step would be to take a look at the code and tinker with it in your development environment of choice. Start with <code>sandbar.example.ideadb.app</code>.

h2. Features

This is the very beginning of this project. Much of the code is a mess at this point and the API is shifting. As features become more complete I will add documentation for them here. The main focus in now on authentication and authorization as I think this is the first feature that others may want to use.

The vaguely named <code>sandbar.library</code> namespace contains a lot of code that will end up in other namespaces in the future. Right now it is a catch-all for code that I am to lazy to organize.

h3. Authentication and Authorization

The code for authentication and authorization is located in the namespace <code>sandbar.auth</code>. For an example of how it may be used, see <code>sandbar.example.ideadb.app</code>. For now, the main focus is on authoriztion based on URIs and user roles.

h4. Configuration

One may create a security configuration that looks something like this:

<pre>
<code>
(def security-config
     [#"/admin.*"                   [:admin :ssl] 
      #"/idea/edit.*"               [:admin :ssl] 
      #"/idea/delete.*"             [:admin :ssl] 
      #"/idea/download.*"           :admin 
      #"/permission-denied.*"       :any
      #"/login.*"                   [:any :ssl] 
      #".*.css|.*.js|.*.png|.*.gif" [:any :any-channel] 
      #".*"                         [#{:admin :user} :nossl]])	
</code>
</pre>

This is configuring two things at once: authorization and channel security. You could do just one or the other if that is all you need. A vector is used for the configuration because the order in which items are entered is important. The vector contains pairs of entries. Each entry has a regular expression literal and a requirement to use if the regular expression matches the current URI. Each requirement may be a vector, a set or a keyword. If it is a vector then it must contain two elements, the first being the role and the second being the channel requirement. Roles can be expressed as either a keyword for the role or as a set of role keywords. Channel security requirements must be one of the keywords :ssl, :nossl or :any-channel. This sounds complex but I think it is simple to understand when looking at the above example.

h4. Applying the configuration to your routes

Once again from the reference application, here is an example of how to use this configuration.

<pre>
<code>
(decorate development-routes
          (with-context @app-context)
          (with-security security-config basic-auth)
          (with-session)
          (with-secure-channel security-config 8080 8443))
</code>
</pre>

<code>with-security</code> and <code>with-secure-channel</code> are middleware functions that use the configuration above to control access to specific URIs and to ensure that the channel security rules are being enforced. Note that these can be used independently of each other.

h4. Authentication function

In the above example I use the <code>basic-auth</code> authentication function from the namespace <code>sandbar.basic_authentication</code>. Authentication functions are a function of the request that return either a valid user or a redirect. This means that you can easily create your own authentication function. A valid user is a map that contains at least two things: a :name key that maps to a user's username and a :roles key that maps to the set of roles that this user belongs to. The role keys that are used in this set must match the roles that are used in your configuration.

The <code>basic-auth</code> function here will redirect the user to a login form.

The <code>sandbar.basic_authentication</code> namespace still needs some work in order to make it more flexible so that anyone can use it in their project no matter where their data is stored or how it is organized.

h4. Authorization

The <code>sandbar.auth</code> namespace includes the functions:

* current-user
* current-username
* current-user-roles
* any-role-granted?

The first three take either the request as an argument or no arguments. The no argument version can be used in any code that is executed within the <code>with-security</code> middleware. The var <code>*current-user*</code> is bound to the current user in <code>with-security</code>.

<code>any-role-granted?</code> takes a request and list or roles as arguments or just a list of roles. If passing only a list roles then it must also be called within <code>with-security</code>.

These functions can be used to authorize access at the function level and should be used in your model to control access to sensitive data.

h4. Authorization Errors

You may use the functions above to determine if the current user is allowed to access data. When you discover that a user is not authenticated or that a user does not have the correct role you may use <code>access-error</code> or <code>authorization-error</code> to raise an error. If an <code>access-error</code> is raised then the user will be redirected to the access denied page. If an <code>authorization-error</code> is raised the your authorization function will be called. If your authentication function returns a valid user then that user will be put in the session and the handler function will be called again.

There are also two macros to that make this even easier. They are <code>ensure-authenticated</code> and <code>ensure-any-role</code>. For example:
 
<pre>
<code>
(ensure-authenticated
  (order-members-only-jacket {:size "medium husky"}))
</code>
</pre>

This will check to ensure that the <code>*current-user*</code> is authenticated and it not then it will not order the jacket but will raise an authentication error.

<pre>
<code>
(ensure-any-role [:user :editor]
  (set-text "something"))
</code>
</pre>

<code>ensure-any-role</code> will first ensure that that the <code>*current-user*</code> is authenticated. If not it will raise an authentication error. It will then ensure that the <code>*current-user*</code> is in one of the roles. If not then it will raise an access error.

h4. TODO

* Upgrade to Compojure 0.4.0. With the new refactor, do you even want to use Compojure? Maybe just Ring?
* Use Compojure's security functions. (How did I miss that?) Where did they go in 0.4.0?
* How about some error handling code!!
* Should be able to configure a default login redirect page. For when a user logs in but there is no redirect page in the session
* Create a new version of app.clj that does not have URI based authentication but does secure data in the model.

h2. Road map

There will be many dependencies between the parts of the project. Therefore I am doing a breadth first rough implementation. This will give me some idea as to how the pieces will fit together and what issues I will run into. I will then go back through and complete each piece one at a time in dependency order. For now, I would like to keep everything in one project to ease implementation, but in the future I may break each piece out into a separate project.

h3. The reference application

The reference application is currently easiest to get running with MySQL. I plan to change this to use Derby by default so that it will be easier for others to test drive.

h3. Scaling server side state

When server side state is needed by any part of the library it will not use Compojure's session management. A session interface will be included in the library. For small applications that don't need to scale, the session is implemented as an in-process atom. When you need to start scaling you can switch implementations to client-server based sessions. This will have the same interface as the in-process sessions but state will be stored in another process or on another machine. This allows you to have sessions that will scale when you need them to without having to use 'sticky' sessions or put transient session state in your system of record.

The client-server model will have a very simple interface and be backed by "FleetDB":http://github.com/mmcgrana/fleetdb.

h3. Tables which may be filtered, sorted and paged

The reference project has some working examples. Each of the tables in the application may be filtered, and sorted on multiple columns. More features will be added in the future and the code will greatly improved over time.

h3. Form layout, validation and error reporting

Working on making it easy to layout and build forms without having to write HTML. There are examples of this in all of the forms in the reference application. The current code needs a lot of work.

h3. User management

Every application that I create needs to home some kind of user management GUI. The goal here is to package this up into a library that I can just include and configure and never have to worry about again. This is also partially implemented.

h3. CSS Builder

Working with CSS on a large project always gets out of control. I want to be able to write my CSS as Clojure code. This currently does not exist.

h2. License

Copyright (C) 2010 Brenton Ashworth

Distributed under the Eclipse Public License, the same as Clojure uses. See the file COPYING.


