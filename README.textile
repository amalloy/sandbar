h1. Sandbar

Sandbar is a library for web applications built on top of Compojure. It contains (will contain) code to help with: 

* scaling server side state
* tables which may be filtered, sorted and paged
* form layout, validation and error reporting
* authorization and authentication
* user management
* CSS builder

The project contains the library code as well a reference application which uses it.

I am creating this library for my own benefit and will be using it in all future web applications that I create. Therefore I will only be focusing on the things that I think will make me most productive.

h2. Running the reference application

The reference application demonstrates how to use the sandbar libraries.

To run the reference application, follow these steps:

# Create a MySQL database on localhost named idea_db
# Create a MySQL user named idea_user@localhost with password 123456789
# Give the above user all privileges on the idea_db database.
# "Install Leiningen":http://github.com/technomancy/leiningen
# Execute the following commands:

<pre>
<code> 
git clone git://github.com/brentonashworth/sandbar.git
cd sandbar
lein deps
lein test
lein repl
(load-file "src/testdrive.clj")
</code>
</pre>

You may now open a browser and go to http://localhost:8080/ideadb/.

There are two user accounts:

username: admin-user
password: admin

username: normal-user
password: password

Log in with one of these accounts and take it for a spin. The next step would be to take a look at the code and tinker with it in your development environment of choice. Start with <code>sandbar.example.ideadb.app</code>.

h2. Features

This is the very beginning of this project. Much of the code is a mess at this point and the API is shifting. As features become more complete I will add documentation for them here. The main focus in now on authentication and authorization as I think this is the first feature that others may want to use.

The vaguely named <code>sandbar.library</code> namespace contains a lot of code that will end up in other namespaces in the future. Right now it is a catch-all for code that I am to lazy to organize.

h3. Authentication and Authorization

The code for authentication and authorization is located in the namespace <code>sandbar.auth</code>. For an example of how it may be used, see <code>sandbar.example.ideadb.app</code>. For now, the main focus is on authoriztion based on URIs and user roles.

h4. Configuration

One may create a security configuration that looks something like this:

<pre>
<code>
(def security-config
     [#"/admin.*"                   [:admin :ssl] 
      #"/idea/edit.*"               [:admin :ssl] 
      #"/idea/delete.*"             [:admin :ssl] 
      #"/idea/download.*"           :admin 
      #"/permission-denied.*"       :any
      #"/login.*"                   [:any :ssl] 
      #".*.css|.*.js|.*.png|.*.gif" [:any :any-channel] 
      #".*"                         [#{:admin :user} :nossl]])	
</code>
</pre>

This is configuring two things at once: authorization and channel security. You could do just one or the other if that is all you need. A vector is used for the configuration because the order in which items are entered is important. The vector contains pairs of entries. Each entry has a regular expression literal and a requirement to use if the regular expression matches the current URI. Each requirement may be a vector, a set or a keyword. If it is a vector then it must contain two elements, the first being the role and the second being the channel requirement. Roles can be expressed as either a keyword for the role or as a set of role keywords. Channel security requirements must be one of the keywords :ssl, :nossl or :any-channel. This sounds complex but I think it is simple to understand when looking at the above example.

h4. Applying the configuration to your routes

Once again from the reference application, here is an example of how to use this configuration.

<pre>
<code>
(decorate development-routes
          (with-context @app-context)
          (with-security security-config basic-auth)
          (with-session)
          (with-secure-channel security-config 8080 8443))
</code>
</pre>

<code>with-security</code> and <code>with-secure-channel</code> are middleware functions that use the configuration above to control access to specific URIs and to ensure that the channel security rules are being enforced. Note that these can be used independently of each other.

h4. Authentication function

In the above example I use the <code>basic-auth</code> authentication function from the namespace <code>sandbar.basic_authentication</code>. Authentication functions are a function of the request that return either a valid user or a redirect. This means that you can easily create your own authentication function. A valid user is a map that contains at least two things: a :name key that maps to a user's username and a :roles key that maps to the set of roles that this user belongs to. The role keys that are used in this set must match the roles that are used in your configuration.

The <code>basic-auth</code> function here will redirect the user to a login form.

The <code>sandbar.basic_authentication</code> namespace still needs some work in order to make it more flexible so that anyone can use it in their project no matter where their data is stored or how it is organized.

h4. Authorization

The <code>sandbar.auth</code> namespace includes the functions:

* current-user
* current-username
* current-user-roles
* any-role-granted?

The first three take either the request as an argument or no arguments. The no argument version can be used in any code that is executed within the <code>with-security</code> middleware. The var <code>*current-user*</code> is bound to the current user in <code>with-security</code>.

<code>any-role-granted?</code> takes a request and list or roles as arguments or just a list of roles. If passing only a list roles then it must also be called within <code>with-security</code>.

These functions can be used to authorize access at the function level and should be used in your model to control access to sensitive data.

h4. Authorization Exceptions

* *access-error*
* *authorization-error*

<pre>
<code>
(kit/raise *access-error* "testing with-security")
</code>
</pre>

h4. TODO

* Use Compojure's security functions. (How did I miss that?)
* How about some error handling code!!
* Should be able to configure a default login redirect page. For when a user logs in but there is no redirect page in the session
* Create a new version of app.clj that does not have URI based authentication but does secure data in the model.
* wrap (kit/raise *access-error* "testing with-security") in a function so that users don't have to know about error-kit: something like <code>(access-exception) (authorization-exception)</code>

h2. Road map

There will be many dependencies between the parts of the project. Therefore I am doing a breadth first rough implementation. This will give me some idea as to how the pieces will fit together and what issues I will run into. I will then go back through and complete each piece one at a time in dependency order. For now, I would like to keep everything in one project to ease implementation, but in the future I may break each piece out into a separate project.

h3. The reference application

The reference application is currently easiest to get running with MySQL. I plan to change this to use Derby by default so that it will be easier for others to test drive.

h3. Scaling server side state

When server side state is needed by any part of the library it will not use Compojure's session management. A session interface will be included in the library. For small applications that don't need to scale, the session is implemented as an in-process atom. When you need to start scaling you can switch implementations to client-server based sessions. This will have the same interface as the in-process sessions but state will be stored in another process or on another machine. This allows you to have sessions that will scale when you need them to without having to use 'sticky' sessions or put transient session state in your system of record.

The client-server model will have a very simple interface and be backed by "FleetDB":http://github.com/mmcgrana/fleetdb.

h3. Tables which may be filtered, sorted and paged

The reference project has some working examples. Each of the tables in the application may be filtered, and sorted on multiple columns. More features will be added in the future and the code will greatly improved over time.

h3. Form layout, validation and error reporting

Working on making it easy to layout and build forms without having to write HTML. There are examples of this in all of the forms in the reference application. The current code needs a lot of work.

h3. User management

Every application that I create needs to home some kind of user management GUI. The goal here is to package this up into a library that I can just include and configure and never have to worry about again. This is also partially implemented.

h3. CSS Builder

Working will CSS on a large project always gets out of control. I want to be able to write my CSS as Clojure code. This currently does not exist.

h2. License

Copyright (C) 2010 Brenton Ashworth

Distributed under the Eclipse Public License, the same as Clojure uses. See the file COPYING.


