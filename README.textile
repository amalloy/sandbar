h1. Sandbar

Sandbar is a library for web applications built on top of Compojure. It contains (will contain) code to help with: 

* scaling server side state
* tables which may be filtered, sorted and paged
* form layout, validation and error reporting
* authorization and authentication
* user management

The project contains the library code as well a reference application which uses it.

h2. Running the reference application

The reference application demonstrates how to use the sandbar libraries.

To run the reference application, follow these steps:

# Create a MySQL database on localhost named idea_db
# Create a MySQL user named idea_user@localhost with password 123456789
# Give the above user all privileges on the idea_db database.
# "Install Leiningen":http://github.com/technomancy/leiningen
# Execute the following commands:

<pre>
<code> 
git clone git://github.com/brentonashworth/sandbar.git
cd sandbar
lein deps
lein test
lein repl
(load-file "src/testdrive.clj")
</code>
</pre>

You may now open a browser and go to http://localhost:8080/ideadb/.

There are two user accounts:

username: admin-user
password: admin

username: normal-user
password: password

Log in with one of these accounts and take it for a spin. The next step would be to take a look at the code and tinker with it in your development environment of choice. Start with <code>sandbar.example.ideadb.app</code>.

h2. Features

This is the very beginning of this project. Much of the code is a mess at this point and the API is shifting. As features become more complete I will add documentation for them here. The main focus in now on authentication and authorization as I think this is the first feature that others may want to use.

The vaguely named <code>sandbar.library</code> namespace contains a lot of code that will end up in other namespaces in the future. Right now it is a catch-all for code that I am to lazy to organize.

h3. Authentication and Authorization

The code for authentication and authorization is located in the namespace <code>sandbar.auth</code>. For an example of how it may be used, see <code>sandbar.example.ideadb.app</code>. For now, the main focus is on authoriztion based on URIs and user roles.

h4. Configuration

One may create a security configuration that looks something like this:

<pre>
<code>
(def security-config
     [#"/admin.*"                   [:admin :ssl] 
      #"/idea/edit.*"               [:admin :ssl] 
      #"/idea/delete.*"             [:admin :ssl] 
      #"/idea/download.*"           :admin 
      #"/permission-denied.*"       :any
      #"/login.*"                   [:any :ssl] 
      #".*.css|.*.js|.*.png|.*.gif" [:any :any-channel] 
      #".*"                         [#{:admin :user} :nossl]])	
</code>
</pre>

This is configuring two things at once: authorization and channel security. You could do just one or the other if that is all you need. A vector is used for the configuration because the order in which items are entered is important. The vector contains pairs of entries. Each entry has a regular expression literal and a requirement to use if the regular expression matches the current URI. Each requirement may be a vector, a set or a keyword. If it is a vector then it must contain two elements, the first being the role and the second being the channel requirement. Roles can be expressed as either a keyword for the role or as a set of role keywords. Channel security requirements must be one of the keywords :ssl, :nossl or :any-channel. This sounds complex but I think it is simple to understand when looking at the above example.

h4. Applying the configuration to your routes

Once again from the reference application, here is an example of how to use this configuration.

<pre>
<code>
(decorate development-routes
          (with-context @app-context)
          (with-security security-config basic-auth)
          (with-session)
          (with-secure-channel security-config 8080 8443))
</code>
</pre>

<code>with-security</code> and <code>with-secure-channel</code> are middleware functions that use the configuration above to control access to specific URIs and to ensure that the channel security rules are being enforced. Note that these can be used independently of each other.

h4. Authentication function

In the above example I use the <code>basic-auth</code> authentication function from the namespace <code>sandbar.basic_authentication</code>. Authentication functions are a function of the request that return either a valid user or a redirect. This means that you can easily create your own authentication function. A valid user is a map that contains at least two things: a :name key that maps to a user's username and a :roles key that maps to the set of roles that this user belongs to. The role keys that are used in this set must match the roles that are used in your configuration.

The <code>basic-auth</code> function here will redirect the user to a login form.

The <code>sandbar.basic_authentication</code> namespace still needs some work in order to make it more flexible so that anyone can use it in their project no matter where their data is stored or how it is organized.

h4. TODO

* Use Compojure's security functions. (How did I miss that?)
* How about some error handling code!!
* Should be able to configure a default login redirect page. For when a user logs in but there is no redirect page in the session.

h2. Road map

The reference application is currently easiest to get running with MySQL. I plan to change this to use Derby by default so that it will be easier for others to test drive.

h3. Scaling server side state

When server side state is needed by any part of the library it will not use Compojure's session management. A session interface will be included in the library. For small applications that don't need to scale, the session is implemented as an in-process atom. When you need to start scaling you can switch implementations to client-server based sessions. This will have the same interface as the in-process sessions but state will be stored in another process or on another machine. This allows you to have sessions that will scale when you need them to without having to use 'sticky' sessions or put transient session state in your system of record.

The client-server model will have a very simple interface and be backed by "FleetDB":http://github.com/mmcgrana/fleetdb.

h3. Tables which may be filtered, sorted and paged

h3. Form layout, validation and error reporting

h3. User management

h2. License

Copyright (C) 2010 Brenton Ashworth

Distributed under the Eclipse Public License, the same as Clojure uses. See the file COPYING.


