h1. Sandbar

This branch currently does not work. I am in the middle of migrating to Compojure 0.4 and Ring 2.0.

Sandbar is a set of libraries for web applications which is designed to be used with "Compojure":http://github.com/weavejester/compojure and/or "Ring":http://github.com/mmcgrana/ring. It contains will contain code to help with: 

* Authorization and authentication
* CSS builder
* Form layout, validation and error reporting
* Tables which may be filtered, sorted and paged
* User management
* Some kind of interface to Lucene (Solr)
* A Ring session storage engine backed by FleetDB, Memcached or mstate???

The name "sandbar" is a surfing reference. A sandbar creates waves which may be surfed. sandbar creates web sites which may be surfed. Sandbars are always in a state of change. So is this project.

The project contains the library code as well as a reference application which uses it.

h2. Running the reference application

The reference application demonstrates how to use the sandbar libraries.

To run the reference application, follow these steps:

# Create a MySQL database on localhost named idea_db
# Create a MySQL user named idea_user@localhost with password 123456789
# Give the above user all privileges on the idea_db database.
# "Install Leiningen":http://github.com/technomancy/leiningen
# Execute the following commands:

<pre>
<code> 
git clone git://github.com/brentonashworth/sandbar.git
cd sandbar
lein deps
lein test
lein repl
(load-file "src/testdrive.clj")
</code>
</pre>

You may now open a browser and go to http://localhost:8080/ideadb/.

There are two user accounts:

username: admin-user
password: admin

username: normal-user
password: password

Log in with one of these accounts and take it for a spin. The next step would be to take a look at the code and tinker with it in your development environment of choice. Start with <code>sandbar.example.ideadb.app</code>.

h2. Features

This is the very beginning of this project. Much of the code is a mess at this point and the API is shifting. As features become more complete, I will add documentation for them here. The main focus is now on authentication and authorization as I think this is the first feature that others may want to use.

The vaguely named <code>sandbar.library</code> namespace contains a lot of code that will end up in other namespaces in the future. Right now it is a catch-all for code that I am too lazy to organize.

h3. Authentication and Authorization

The code for authentication and authorization is located in the namespace <code>sandbar.auth</code>. For an example of how it may be used, see <code>sandbar.example.ideadb.app</code>.

h4. Configuration

An example security configuration is shown below:

<pre>
<code>
(def security-config
     [#"/admin.*"                   [:admin :ssl] 
      #"/idea/edit.*"               [:admin :ssl] 
      #"/idea/delete.*"             [:admin :ssl] 
      #"/idea/download.*"           :admin 
      #"/permission-denied.*"       :any
      #"/login.*"                   [:any :ssl] 
      #".*.css|.*.js|.*.png|.*.gif" [:any :any-channel] 
      #".*"                         [#{:admin :user} :nossl]])	
</code>
</pre>

This is configuring two things at once: authorization and channel security. You could do just one or the other if that is all you need. A vector is used for the configuration because the order in which items are entered is important. The vector contains pairs of entries. Each entry has a regular expression literal and a requirement to be used if the regular expression matches the current URI. Each requirement may be a vector, a set or a keyword. If it is a vector then it must contain two elements, the first being the role and the second being the channel requirement. Roles can be expressed as either a keyword for the role or as a set of role keywords. Channel security requirements must be one of the keywords :ssl, :nossl or :any-channel. This sounds complex but I think it is simple to understand when looking at the above example.

h4. Applying the configuration to your routes

Once again from the reference application, here is an example of how to use this configuration.

<pre>
<code>
(def app
  (-> development-routes
      with-db-configured
      (with-security security-config basic-auth)
      wrap-stateful-session
      wrap-params
      (wrap-file "public")
      wrap-file-info
      (with-secure-channel security-config 8080 8443)
      wrap-stacktrace))
</code>
</pre>

<code>with-security</code> and <code>with-secure-channel</code> are middleware functions that use the configuration above to control access to specific URIs and to ensure that the channel security rules are being enforced. Note that these can be used independently of each other.

h4. Authentication function

In the above example, the <code>basic-auth</code> authentication function comes from the namespace <code>sandbar.basic_authentication</code>. Authentication functions are functions of the request that return either a valid user or a redirect. This means that one may easily create one's own authentication function. A valid user is a map that contains at least two things: a :name key that maps to a user's username and a :roles key that maps to the set of roles that the user belongs to. The role keywords that are used in this set must match the role keywords that are used in your configuration.

The <code>basic-auth</code> function here will redirect the user to a login form.

The <code>sandbar.basic_authentication</code> namespace still needs some work in order to make it more flexible. Anyone should be able to use it in their project no matter where their data is stored or how it is organized.

h4. Authorization

The <code>sandbar.auth</code> namespace includes the functions:

* current-user
* current-username
* current-user-roles
* any-role-granted?

The first three take no arguments. These functions must be used in code that is executed downstream of the <code>with-security</code> middleware. The var <code>*current-user*</code> is bound to the current user in <code>with-security</code>. Remember that <code>*current-user*</code> is only bound in the current thread so if you need to use more that one thread you will have to deref this value and pass it into your threaded code.

<code>any-role-granted?</code> takes a list of roles as its arguments. This function must also be called downstream from <code>with-security</code> for the reasons mentioned above.

These functions can be used to authorize access at the function level and should be used in your model to control access to sensitive data.

h4. Authorization Errors

You may use the functions above to determine if the current user is allowed to access data. When it is determined that a user is not authenticated or does not have the correct role, use <code>access-error</code> or <code>authorization-error</code> to raise an error. If an <code>access-error</code> is raised then the user will be redirected to the access denied page. If an <code>authorization-error</code> is raised, the authorization function will be called. If the authentication function returns a valid user then that user will be put in the session and the handler function will be called again.

There are also two macros which make this even easier. They are <code>ensure-authenticated</code> and <code>ensure-any-role</code>. For example:
 
<pre>
<code>
(ensure-authenticated
  (order-members-only-jacket {:size "medium husky"}))
</code>
</pre>

This will ensure that the <code>*current-user*</code> is authenticated, raising an authentication error if she is not and processing the order if she is.

<pre>
<code>
(ensure-any-role [:user :editor]
  (set-text "something"))
</code>
</pre>

<code>ensure-any-role</code> will first ensure that the <code>*current-user*</code> is authenticated. If not, it will raise an authentication error. It will then ensure that the <code>*current-user*</code> is in one of the roles, raising an access error if none are found.

h4. TODO

* Upgrade to Compojure 0.4.0.
* Use Compojure's security functions which are now in Ring cookie.clj.
* How about some error handling code?
* Should be able to configure a default login redirect page. For when a user logs in but there is no redirect page in the session
* Create a new version of app.clj that does not have URI based authentication but instead secures data in the model.
* Make it easy to create a login form that may be embedded within a page. After login the user would be forwarded to the default "welcome" page described above.

h2. Road map

For now, I would like to keep everything in one project to ease implementation, but in the future I may break each piece out into a separate project.

h3. The reference application

The reference application is currently easiest to get running with MySQL. I plan to change this to use Derby by default so that it will be easier for others to test drive and evaluate.

h3. Tables which may be filtered, sorted and paged

The reference project has some working examples. Each of the tables in the application may be filtered and sorted on multiple columns. More features will be added in the future and the code will be improved over time.

h3. Form layout, validation and error reporting

Working on making it easy to layout and build forms without having to write HTML. There are examples of this in all of the forms in the reference application. The current code needs a lot of work.

h3. User management

Every application that I create needs some kind of user management GUI. The goal here is to package this up into a library that I can include and configure and never have to worry about again. This is partially implemented.

h3. CSS Builder

Working with CSS on a large project always gets out of control. I want to be able to write my CSS as Clojure code like "hiccup":http://github.com/weavejester/hiccup does for html. This currently does not exist.

h3. A Ring session storage engine

Create a session store for Ring that will save session data in a remote FleetDB server, Memcached or mstate. I can put this off until later and just use the memory-store provided with Ring. If I put it off, maybe someone else will do it first.

h2. License

Copyright (C) 2010 Brenton Ashworth

Distributed under the Eclipse Public License, the same as Clojure uses. See the file COPYING.





