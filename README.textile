h1. Sandbar

"Install Leiningen":http://github.com/technomancy/leiningen

Sandbar is a library for web applications built on top of "Compojure":http://github.com/weavejester/compojure and "Ring":http://github.com/mmcgrana/ring. It contains (or will contain) code to help with: 

* Scaling server side state
* Tables which may be filtered, sorted and paged
* Form layout, validation and error reporting
* Authorization and authentication
* User management
* CSS builder
* Some kind of interface to Lucene (Solr)

The project contains the library code as well as a reference application which uses it.

h2. Motivation

There is one major difference in philosophy between this project and Compojure or Ring. The main focus of this library is stateful web applications. There is not one right way to create a web application. Different applications have different requirements. Some benefit from a more stateful approach, others from a restful approach. But you will say, stateful does not scale? It does scale, it's just not as easy. The Compojure/Ring approach is more stateless and restful with a functional style of session management.

<table align="center">
<tr><td>
<img src="http://www.drawbacksolutions.com/images/fpl/ring-sessions.png" 
     alt="Ring Sessions" />
</td></tr>
<tr><td>*Figure 1:* Compojure/Ring sessions</td></tr>
</table>

If your application is more stateful then it can sometimes be awkward to work with. Sandbar thinks of sessions that are more like your database except faster and without all of the database pain. You should be able to get something from, and put something in, the session from anywhere in your application. Working with the session should be orthogonal to the request and response.

<table align="center">
<tr><td>
	<img src="http://www.drawbacksolutions.com/images/fpl/sandbar-sessions.png" 
	     alt="Sandbar Sessions" />
</td></tr>
<tr><td>*Figure 2:* Sandbar sessions</td></tr>
</table>

In the past you have had a few choices as to where you would put session data. You can store it in memory, in a cookie or in your database. There is a problem with each of these. In memory does not scale, cookies have limited space and the database is too much work and too slow. Also, session data is transient, you usually only need it for a short period of time. It just seems wrong to mix this into your system of record.

The approach that I am advocating is to store session data in a memory-only, schema-free database. This library will have a simple interface to the session. For small applications the session will be stored in an atom in memory. When you need to start scaling you can switch to client-server mode without having to change any of your code. In client-server mode, the interface will handle sending and retrieving data from the session store. Because we are using an in-memory database it will be fast and because it is schema-free we will be able to store arbitrary maps without a lot of configuration.

Java application servers such as Tomcat have ways of storing and scaling session data. The problem with this approach is that if forces you to use "sticky" sessions. This means that once you start using one application sever you will continue to be routed to that server as long as it is running. If the server goes down, you will then be routed to a different server. Another way to scale session data is to use Terracotta. But again this requires "sticky" sessions.

I believe that a schema-free, in-memory database solution is better and easier to scale.

Here is an example of how this would work in a situation with multiple application servers. Imagine that you are filling in a form which then gets validated and does not pass validation. You then want to redirect the user to the form and display error messages for each field. This involves two requests. The first is the initial form submission. This request is then redirected back to the form. This second request will display the form and any error messages. The form errors will be stored in the flash which is implemented on top of sessions. If you have multiple application servers and are not using "sticky" sessions then the second request may go to a different application server.

<table align="center">
<tr><td>
	<img src="http://www.drawbacksolutions.com/images/fpl/request-response-1.png" 
	     alt="Sandbar Sessions" />
</td></tr>
<tr><td>*Figure 3:* Form submission request</td></tr>
</table>

In Figure 3 we show the initial request. This is the form submission. The form is validated and then the session is updated by simultaneously sending messages to two session servers. The "Put in Session" step happens in another thread so the application does not have to wait for it to finish before returning the redirect to the client.

<table align="center">
<tr><td>
	<img src="http://www.drawbacksolutions.com/images/fpl/request-response-2.png" 
	     alt="Sandbar Sessions" />
</td></tr>
<tr><td>*Figure 4:* Redirect to form request</td></tr>
</table>

In Figure 4 we see the redirect request. This request goes to a different application server (A2) which then loads the session data from the session server (S2). Depending on your needs, you will be able to configure any number of session servers and link them up however you want.

I am thinking of using "FleetDB":http://github.com/mmcgrana/fleetdb as the session store.

h2. Running the reference application

The reference application demonstrates how to use the sandbar libraries.

To run the reference application, follow these steps:

# Create a MySQL database on localhost named idea_db
# Create a MySQL user named idea_user@localhost with password 123456789
# Give the above user all privileges on the idea_db database.
# "Install Leiningen":http://github.com/technomancy/leiningen
# Execute the following commands:

<pre>
<code> 
git clone git://github.com/brentonashworth/sandbar.git
cd sandbar
lein deps
lein test
lein repl
(load-file "src/testdrive.clj")
</code>
</pre>

You may now open a browser and go to http://localhost:8080/ideadb/.

There are two user accounts:

username: admin-user
password: admin

username: normal-user
password: password

Log in with one of these accounts and take it for a spin. The next step would be to take a look at the code and tinker with it in your development environment of choice. Start with <code>sandbar.example.ideadb.app</code>.

h2. Features

This is the very beginning of this project. Much of the code is a mess at this point and the API is shifting. As features become more complete I will add documentation for them here. The main focus in now on authentication and authorization as I think this is the first feature that others may want to use.

The vaguely named <code>sandbar.library</code> namespace contains a lot of code that will end up in other namespaces in the future. Right now it is a catch-all for code that I am to lazy to organize.

h3. Authentication and Authorization

The code for authentication and authorization is located in the namespace <code>sandbar.auth</code>. For an example of how it may be used, see <code>sandbar.example.ideadb.app</code>. For now, the main focus is on authoriztion based on URIs and user roles.

h4. Configuration

One may create a security configuration that looks something like this:

<pre>
<code>
(def security-config
     [#"/admin.*"                   [:admin :ssl] 
      #"/idea/edit.*"               [:admin :ssl] 
      #"/idea/delete.*"             [:admin :ssl] 
      #"/idea/download.*"           :admin 
      #"/permission-denied.*"       :any
      #"/login.*"                   [:any :ssl] 
      #".*.css|.*.js|.*.png|.*.gif" [:any :any-channel] 
      #".*"                         [#{:admin :user} :nossl]])	
</code>
</pre>

This is configuring two things at once: authorization and channel security. You could do just one or the other if that is all you need. A vector is used for the configuration because the order in which items are entered is important. The vector contains pairs of entries. Each entry has a regular expression literal and a requirement to use if the regular expression matches the current URI. Each requirement may be a vector, a set or a keyword. If it is a vector then it must contain two elements, the first being the role and the second being the channel requirement. Roles can be expressed as either a keyword for the role or as a set of role keywords. Channel security requirements must be one of the keywords :ssl, :nossl or :any-channel. This sounds complex but I think it is simple to understand when looking at the above example.

h4. Applying the configuration to your routes

Once again from the reference application, here is an example of how to use this configuration.

<pre>
<code>
(decorate development-routes
          (with-context @app-context)
          (with-security security-config basic-auth)
          (with-session)
          (with-secure-channel security-config 8080 8443))
</code>
</pre>

<code>with-security</code> and <code>with-secure-channel</code> are middleware functions that use the configuration above to control access to specific URIs and to ensure that the channel security rules are being enforced. Note that these can be used independently of each other.

h4. Authentication function

In the above example I use the <code>basic-auth</code> authentication function from the namespace <code>sandbar.basic_authentication</code>. Authentication functions are a function of the request that return either a valid user or a redirect. This means that you can easily create your own authentication function. A valid user is a map that contains at least two things: a :name key that maps to a user's username and a :roles key that maps to the set of roles that this user belongs to. The role keys that are used in this set must match the roles that are used in your configuration.

The <code>basic-auth</code> function here will redirect the user to a login form.

The <code>sandbar.basic_authentication</code> namespace still needs some work in order to make it more flexible so that anyone can use it in their project no matter where their data is stored or how it is organized.

h4. Authorization

The <code>sandbar.auth</code> namespace includes the functions:

* current-user
* current-username
* current-user-roles
* any-role-granted?

The first three take either the request as an argument or no arguments. The no argument version can be used in any code that is executed within the <code>with-security</code> middleware. The var <code>*current-user*</code> is bound to the current user in <code>with-security</code>.

<code>any-role-granted?</code> takes a request and list or roles as arguments or just a list of roles. If passing only a list roles then it must also be called within <code>with-security</code>.

These functions can be used to authorize access at the function level and should be used in your model to control access to sensitive data.

h4. Authorization Errors

You may use the functions above to determine if the current user is allowed to access data. When you discover that a user is not authenticated or that a user does not have the correct role you may use <code>access-error</code> or <code>authorization-error</code> to raise an error. If an <code>access-error</code> is raised then the user will be redirected to the access denied page. If an <code>authorization-error</code> is raised the your authorization function will be called. If your authentication function returns a valid user then that user will be put in the session and the handler function will be called again.

There are also two macros to that make this even easier. They are <code>ensure-authenticated</code> and <code>ensure-any-role</code>. For example:
 
<pre>
<code>
(ensure-authenticated
  (order-members-only-jacket {:size "medium husky"}))
</code>
</pre>

This will check to ensure that the <code>*current-user*</code> is authenticated and it not then it will not order the jacket but will raise an authentication error.

<pre>
<code>
(ensure-any-role [:user :editor]
  (set-text "something"))
</code>
</pre>

<code>ensure-any-role</code> will first ensure that that the <code>*current-user*</code> is authenticated. If not it will raise an authentication error. It will then ensure that the <code>*current-user*</code> is in one of the roles. If not then it will raise an access error.

h4. TODO

* Upgrade to Compojure 0.4.0. With the new refactor, do you even want to use Compojure? Maybe just Ring 0.2.0?
* Use Compojure's security functions. (How did I miss that?) Where did they go in 0.4.0?
* How about some error handling code!!
* Should be able to configure a default login redirect page. For when a user logs in but there is no redirect page in the session
* Create a new version of app.clj that does not have URI based authentication but does secure data in the model.

h2. Road map

There will be many dependencies between the parts of the project. Therefore I am doing a breadth first rough implementation. This will give me some idea as to how the pieces will fit together and what issues I will run into. I will then go back through and complete each piece one at a time in dependency order. For now, I would like to keep everything in one project to ease implementation, but in the future I may break each piece out into a separate project.

h3. The reference application

The reference application is currently easiest to get running with MySQL. I plan to change this to use Derby by default so that it will be easier for others to test drive.

h3. Tables which may be filtered, sorted and paged

The reference project has some working examples. Each of the tables in the application may be filtered, and sorted on multiple columns. More features will be added in the future and the code will greatly improved over time.

h3. Form layout, validation and error reporting

Working on making it easy to layout and build forms without having to write HTML. There are examples of this in all of the forms in the reference application. The current code needs a lot of work.

h3. User management

Every application that I create needs to home some kind of user management GUI. The goal here is to package this up into a library that I can just include and configure and never have to worry about again. This is also partially implemented.

h3. CSS Builder

Working with CSS on a large project always gets out of control. I want to be able to write my CSS as Clojure code like "clj-html":http://github.com/mmcgrana/clj-html or "hiccup":http://github.com/weavejester/hiccup do for html. This currently does not exist.

h2. License

Copyright (C) 2010 Brenton Ashworth

Distributed under the Eclipse Public License, the same as Clojure uses. See the file COPYING.


